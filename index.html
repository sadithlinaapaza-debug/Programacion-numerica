<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Repositorio - Programación Numérica</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg: #E8F6FF; /* azul pastel claro */
      --card: #fffef6;
      --accent: #2b6cb0;
      --muted: #23415a;
      --shadow: 0 6px 18px rgba(35,65,90,0.06);
      --radius: 12px;
      --mono: 'Fira Code', monospace;
      --ui: 'Inter', system-ui, Arial, sans-serif;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--ui);
      background:var(--bg);
      color:var(--muted);
      -webkit-font-smoothing:antialiased;
      line-height:1.55;
      padding:24px;
    }
    .container{max-width:1100px;margin:0 auto}

    /* Header principal (información académica) */
    .site-header{
      background: linear-gradient(90deg, rgba(255,255,255,0.6), rgba(255,255,255,0.4));
      border-radius:14px;padding:18px;margin-bottom:20px;display:flex;gap:18px;align-items:center;box-shadow:var(--shadow)
    }
    .badge{
      background:linear-gradient(135deg,var(--accent),#7fb3ff);color:white;font-weight:700;padding:12px 16px;border-radius:10px;font-size:18px
    }
    .site-header .meta{display:flex;flex-direction:column;gap:4px}
    .site-header h1{margin:0;font-size:18px}
    .site-header p{margin:0;font-size:13px;color:rgba(35,65,90,0.85)}

    /* Contact & roles */
    .roles{display:flex;gap:12px;margin-top:10px;flex-wrap:wrap}
    .role{background:var(--card);border-radius:10px;padding:10px 12px;border:1px solid rgba(35,65,90,0.06);font-size:13px}

    /* Grid */
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:18px;margin-top:20px}
    .card{background:var(--card);border-radius:var(--radius);padding:18px;box-shadow:var(--shadow);border:1px solid rgba(35,65,90,0.04)}
    .card h3{margin:0 0 8px 0;font-size:15px;color:var(--muted)}
    .card ul{padding-left:0;margin:0;list-style:none}
    .card li{margin-bottom:8px;font-size:13px}
    pre{background:#fcfeff;padding:12px;border-radius:8px;overflow:auto;font-family:var(--mono);font-size:13px;color:#0b2540}
    a.download{color:var(--accent);font-weight:700;text-decoration:none}

    /* Plantilla para tareas futuras */
    .template{border:2px dashed rgba(35,65,90,0.08);padding:14px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.3))}
    .template code{display:block;background:transparent;padding:0;color:var(--muted);font-family:var(--mono)}

    @media(max-width:420px){body{padding:12px}}
  </style>
</head>
<body>
  <main class="container">
    <header class="site-header">
      <div class="badge">PN</div>
      <div>
        <h1>Programación Numérica — FINESI</h1>
        <p><strong>Universidad Nacional del Altiplano - Puno</strong></p>
        <div class="roles">
          <div class="role">Estudiante: <strong>Sadith Lina Apaza</strong></div>
          <div class="role">Docente: <strong>ING. FRED TORRES CRUZ</strong></div>
        </div>
      </div>
    </header>

    <section class="grid">

      <!-- Módulo 1 -->
      <article class="card">
        <h3>Módulo 1 — Analizador de funciones</h3>
        <ul>
          <li><b>Fecha:</b> 2025-09-10</li>
          <li><b>Tema:</b> Funciones</li>
          <li><b>Entrega:</b> tarea 01</li>
        </ul>
        <pre><code class="language-python">class Analizador:
    def __init__(self, funcion):
        self.funcion = funcion

    def obtener_variables(self):
        variables = []
        for caracter in self.funcion:
            if caracter.isalpha() and caracter not in variables:
                variables.append(caracter)
        return variables

    def obtener_operaciones(self):
        operaciones = []
        for caracter in self.funcion:
            if caracter in "+-*/":
                operaciones.append(caracter)
        return operaciones

funcion = input("Escribe una función matemática: ")

analizador = Analizador(funcion)

print("
 RESULTADO ")
print("Variables encontradas:", analizador.obtener_variables())
print("Operaciones encontradas:", analizador.obtener_operaciones())</code></pre>
        <p><a class="download" href="analizador.py" download>Descargar analizador.py</a></p>
        <p class="reflection"><strong>Reflexión:</strong> —</p>
      </article>

      <!-- Módulo 2 -->
      <article class="card">
        <h3>Módulo 2 — Graficadora</h3>
        <ul>
          <li><b>Fecha:</b> 2025-09-23</li>
          <li><b>Tema:</b> gráfica funciones</li>
          <li><b>Entrega:</b> Práctica 02</li>
        </ul>
        <pre><code class="language-python">class GraficadoraLineal:
    def __init__(self, expresion1, expresion2):
        self.expresion1 = expresion1
        self.expresion2 = expresion2
        self.x = []
        self.y1 = []
        self.y2 = []

    def generar_valores(self):
        x = -10
        while x <= 10:
            self.x.append(x)
            self.y1.append(eval(self.expresion1))
            self.y2.append(eval(self.expresion2))
            x = x + 1

    def graficar_consola(self):
        for i in range(len(self.x)):
            espacios1 = " " * (self.y1[i] + 20)
            linea = f"x={self.x[i]:>3} | {espacios1}*"

            espacios2 = " " * (self.y2[i] + 20)
            linea2 = f"{espacios2}#"

            print(linea + linea2)

f1 = input("Ingresa la primera funcion lineal: ")
f2 = input("Ingresa la segunda funcion lineal: ")

mi_grafica = GraficadoraLineal(f1, f2)
mi_grafica.generar_valores()
mi_grafica.graficar_consola()</code></pre>
        <p><a class="download" href="#" download>Descargar graficadora.py</a></p>
        <p class="reflection"><strong>Reflexión:</strong> —</p>
      </article>

       <!-- Módulo 3 -->
      <article class="card">
        <h3>Módulo 3 — Restricciones</h3>
        <ul>
          <li><b>Fecha:</b> 2025-10-09</li>
          <li><b>Tema:</b> restriciones</li>
          <li><b>Entrega:</b> Práctica 03</li>
        </ul>
        <pre><code class="language-python">
          class Restriccion:
    def __init__(self, expresion):
        self.expresion = expresion.replace(" ", "")

    def cumple(self, x, y):
        expr = self.expresion.replace("x", str(x)).replace("y", str(y))
        try:
            return eval(expr)
        except Exception as e:
            print("Error evaluando la restricción:", self.expresion, "->", e)
            return False

class ProblemaASCII:
    def __init__(self):
        self.restricciones = []

    def ingresar_datos(self):
        n = int(input("¿Cuántas restricciones?: ").strip())
        for i in range(n):
            r = input(f"Restricción #{i+1}: ")
            self.restricciones.append(Restriccion(r))

        print("\n--- RANGOS ---")
        self.x_min = int(input("x mínimo : ").strip())
        self.x_max = int(input("x máximo : ").strip())
        self.y_min = int(input("y mínimo : ").strip())
        self.y_max = int(input("y máximo : ").strip())

        paso = input("Paso de la cuadrícula (enteros, por defecto 1): ").strip()
        self.step = int(paso) if paso != "" else 1

    def punto_factible(self, x, y):
        for r in self.restricciones:
            if not r.cumple(x, y):
                return False
        return True

    def listar_puntos_factibles(self):
        factibles = []
        for y in range(self.y_min, self.y_max + 1, self.step):
            for x in range(self.x_min, self.x_max + 1, self.step):
                if self.punto_factible(x, y):
                    factibles.append((x, y))
        return factibles

    def imprimir_ascii(self):
        xs = list(range(self.x_min, self.x_max + 1, self.step))
        ys = list(range(self.y_min, self.y_max + 1, self.step))

        print("\n=== GRÁFICA  ===")
        header = "    " 
        for x in xs:
            if (x - self.x_min) % (max(1, (len(xs)//10))) == 0:
                header += f"{str(x).rjust(2)}"
            else:
                header += "  "
        print(header)

        for y in reversed(ys): 
            line = f"{str(y).rjust(3)} "  
            for x in xs:
                if self.punto_factible(x, y):
                    line += " #"
                else:
                    line += " ."
            print(line)

        footer = "    "
        for x in xs:
            if (x - self.x_min) % (max(1, (len(xs)//10))) == 0:
                footer += f"{str(x).rjust(2)}"
            else:
                footer += "  "
        print(footer)
        print("\nLeyenda: '#' punto factible, '.' no factible.")

    def ejecutar(self):
        self.ingresar_datos()
        factibles = self.listar_puntos_factibles()
        if not factibles:
            print("\nNo se encontraron puntos factibles en el rango dado.")
        else:
            print(f"\nSe encontraron {len(factibles)} puntos factibles:")
            for p in factibles[:20]:
                print(" ", p)
        self.imprimir_ascii()

def main():
    prog = ProblemaASCII()
    prog.ejecutar()

if __name__ == "__main__":
    main()
        </code></pre>
        <p><a class="download" href="Restricciones.py" download>Descargar Restricciones.py</a></p>
        <p><a class="download" href="Restricciones.pdf" download>Descargar Restricciones.pdf</a></p>
        <p class="reflection"><strong>Reflexión:</strong> —</p>
      </article>

      <!-- Módulo 4 -->
      <article class="card">
        <h3>Módulo 4 — Metodo Newton Raphson</h3>
        <ul>
          <li><b>Fecha:</b> 2025-10-08</li>
          <li><b>Tema:</b> Newton Raphson</li>
          <li><b>Entrega:</b> Práctica 04</li>
        </ul>
        <pre><code class="language-python">import math

class NewtonRaphson:
    def __init__(self):
        pass

    def f(self, x, expr):
        return eval(expr, {"__builtins__":None}, {"x":x, **math.__dict__})

    def ejecutar(self):
        expr = input("Ingrese f(x): ").strip()
        dexpr = input("Ingrese f'(x): ").strip()
        x0 = float(input("x0: "))
        tol = float(input("Tolerancia (ej: 1e-6): "))
        maxit = int(input("Iteraciones maximas: "))
        x = x0
        for i in range(1, maxit+1):
            fx = self.f(x, expr)
            dfx = self.f(x, dexpr)
            if dfx == 0:
                print("Derivada cero. Deteniendo.")
                return
            x_new = x - fx/dfx
            if abs(x_new - x) < tol:
                print(f"Raíz: {x_new}")
                print(f"f(raíz): {self.f(x_new, expr)}")
                print(f"Iteraciones: {i}")
                return
            x = x_new
        print(f"Resultado tras {maxit} iter: {x}")
        print(f"f(aprox): {self.f(x, expr)}")

if __name__ == "__main__":
    NewtonRaphson().ejecutar()</code></pre>
        <p><a class="download" href="Newton Raphson.py" download>Descargar Newton Raphson.py</a></p>
        <p class="reflection"><strong>Reflexión:</strong> —</p>
      </article>

      <!-- Módulo 5 -->
      <article class="card">
        <h3>Módulo 5 — Metodo Punto Fijo</h3>
        <ul>
          <li><b>Fecha:</b> 2025-10-08</li>
          <li><b>Tema:</b> Punto Fijo</li>
          <li><b>Entrega:</b> Práctica 05</li>
        </ul>
        <pre><code class="language-python">
          import math

class PuntoFijo:
    def __init__(self):
        pass

    def g(self, x, expr):
        safe_locals = {
            "x": x,
            "ln": math.log,        
            "log": math.log,       
            "log10": math.log10,   
            "exp": math.exp,
            "sqrt": math.sqrt,
            "e": math.e,
            "pi": math.pi,
            **{k: getattr(math, k) for k in dir(math) if not k.startswith("__")}
        }
        return eval(expr, {"__builtins__": None}, safe_locals)

    def ejecutar(self):
        expr = input("Ingrese g(x) para x = g(x) (ej: (x+2/x)/2 o ln(x+1)): ").strip()
        x0 = float(input("x0: "))
        tol = float(input("Tolerancia (ej: 1e-6): "))
        maxit = int(input("Iteraciones máximas: "))

        x = x0
        for i in range(1, maxit + 1):
            x_new = self.g(x, expr)
            error = abs((x_new - x) / x_new) * 100 if x_new != 0 else float('inf')

            print(f"Iteración {i}: x = {x_new:.10f}, Error = {error:.6f}%")

            if error < tol * 100:  
                print(f"\nPunto fijo: {x_new}")
                print(f"Iteraciones: {i}")
                print(f"Error porcentual final: {error:.6f}%")
                return

            x = x_new

        print(f"\nResultado tras {maxit} iteraciones: {x}")
        print(f"Error porcentual final: {error:.6f}%")

if __name__ == "__main__":
    PuntoFijo().ejecutar()
    </code></pre>
        <p><a class="download" href="punto fijo.py" download>Descargar Punto Fijo 1.py</a></p>
        <p class="reflection"><strong>Reflexión:</strong> —</p>
      </article>

      <!-- Módulo 6 -->
      <article class="card">
        <h3>Módulo 6 — Metodo Biseccion</h3>
        <ul>
          <li><b>Fecha:</b> 2025-10-16</li>
          <li><b>Tema:</b> Biseccion</li>
          <li><b>Entrega:</b> Práctica 06</li>
        </ul>
        <pre><code class="language-python">
        import math

class Biseccion:
    def __init__(self):
        pass

    def f(self, x, expr):
        return eval(expr, {"__builtins__":None}, {"x":x, **math.__dict__})

    def ejecutar(self):
        expr = input("Ingrese f(x) como expresión en Python (ej: x**3-2*x-5): ").strip()
        a = float(input("a: "))
        b = float(input("b: "))
        tol = float(input("Tolerancia (ej: 1e-6): "))
        maxit = int(input("Iteraciones maximas: "))
        fa = self.f(a, expr)
        fb = self.f(b, expr)
        if fa * fb > 0:
            print("No hay cambio de signo en el intervalo.")
            return
        for i in range(1, maxit+1):
            c = (a + b) / 2.0
            fc = self.f(c, expr)
            if abs(fc) == 0 or (b - a) / 2.0 < tol:
                print(f"Raíz: {c}")
                print(f"f(raíz): {fc}")
                print(f"Iteraciones: {i}")
                return
            if fa * fc < 0:
                b = c
                fb = fc
            else:
                a = c
                fa = fc
        print(f"Raíz aproximada tras {maxit} iter: {c}")
        print(f"f(raíz): {fc}")

if __name__ == "__main__":
    Biseccion().ejecutar()
    </code></pre>
        <p><a class="download" href="Método de Bisección.py" download>Descargar Método de Bisección .py</a></p>
        <p class="reflection"><strong>Reflexión:</strong> —</p>
      </article>

      <!-- Módulo 7 -->
      <article class="card">
        <h3>Módulo 7 — Método de Regula Falsi(Falsa Posición)</h3>
        <ul>
          <li><b>Fecha:</b> 2025-10-16</li>
          <li><b>Tema:</b> Método de Regula Falsi</li>
          <li><b>Entrega:</b> Práctica 07</li>
        </ul>
        <pre><code class="language-python">
        import math

class RegulaFalsi:
    def __init__(self):
        pass

    def f(self, x, expr):
        return eval(expr, {"__builtins__":None}, {"x":x, **math.__dict__})

    def ejecutar(self):
        expr = input("Ingrese f(x) como expresión en Python (ej: x**3-2*x-5): ").strip()
        a = float(input("a: "))
        b = float(input("b: "))
        tol = float(input("Tolerancia (ej: 1e-6): "))
        maxit = int(input("Iteraciones maximas: "))
        fa = self.f(a, expr)
        fb = self.f(b, expr)
        if fa * fb > 0:
            print("No hay cambio de signo en el intervalo.")
            return
        c = a
        for i in range(1, maxit+1):
            c = (a * fb - b * fa) / (fb - fa)
            fc = self.f(c, expr)
            if abs(fc) < tol:
                print(f"Raíz: {c}")
                print(f"f(raíz): {fc}")
                print(f"Iteraciones: {i}")
                return
            if fa * fc < 0:
                b = c
                fb = fc
            else:
                a = c
                fa = fc
        print(f"Raíz aproximada tras {maxit} iter: {c}")
        print(f"f(raíz): {self.f(c, expr)}")

if __name__ == "__main__":
    RegulaFalsi().ejecutar()

    </code></pre>
        <p><a class="download" href="Método de Regula Falsi (Falsa Posición).py" download>Descargar Método de Regula Falsi (Falsa Posición).py</a></p>
        <p class="reflection"><strong>Reflexión:</strong> —</p>
      </article>

    </section>

    
      </div>
    </section>

  </main>
</body>
</html>
