<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Portafolio ‚Äî Programaci√≥n Num√©rica FINESI</title>

  <!-- Google fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- MathJax -->
  <script>
    window.MathJax = {
      tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async></script>

  <style>
    :root{
      --bg:#E8F6FF; /* celeste muy claro */
      --card:#fffef6;
      --accent:#2b6cb0;
      --muted:#23415a;
      --shadow:0 8px 28px rgba(35,65,90,0.08);
      --radius:16px;
      --mono:'Fira Code', monospace;
      --ui:'Inter', system-ui, Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--ui);
      background:var(--bg);
      color:var(--muted);
      -webkit-font-smoothing:antialiased;
      padding:28px;
    }

    .sheet{
      max-width:1100px;
      margin:0 auto;
      background:linear-gradient(180deg, rgba(255,255,255,0.98), rgba(255,255,255,0.96));
      border-radius:18px;
      padding:28px;
      box-shadow:var(--shadow);
      border:1px solid rgba(35,65,90,0.03);
    }

    /* Header */
    .hero{
      background: linear-gradient(90deg, rgba(255,255,255,0.6), rgba(255,255,255,0.4));
      border-radius:14px;
      padding:22px;
      text-align:center;
      margin-bottom:20px;
      box-shadow:0 6px 18px rgba(35,65,90,0.04);
    }
    .hero h1{ margin:4px 0; font-size:20px; color:var(--accent); font-weight:700; letter-spacing:0.02em; text-transform:uppercase; }
    .hero h2{ margin:6px 0; font-size:18px; color:#034a7a; font-weight:700; text-transform:uppercase; }
    .hero h3{ margin:6px 0; font-size:16px; color:#0b3d66; font-weight:600; }
    .hero p{ margin:4px 0; color:var(--muted) }

    /* Nav */
    .nav { display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin-bottom:18px; }
    .nav button{
      background:linear-gradient(180deg,#66a8ff,#007acc);
      color:white; border:0; padding:10px 16px; border-radius:10px; font-weight:700; cursor:pointer;
      box-shadow:0 6px 14px rgba(3,76,130,0.12);
    }
    .nav button:hover{ transform:translateY(-3px) }

    /* Sections */
    .section{ display:none; padding:18px; background:var(--card); border-radius:12px; margin-bottom:18px; box-shadow:0 6px 18px rgba(35,65,90,0.04) }
    .section.active{ display:block; }

    .section h2{ margin-top:0; color:var(--accent); font-size:18px }
    .theory{ color:#0b3d66; line-height:1.6; margin-bottom:14px; font-size:14px; }

    pre{ background:#fcfeff; padding:12px; border-radius:8px; overflow:auto; font-family:var(--mono); font-size:13px; color:#0b2540; }
    .download{ color:var(--accent); font-weight:700; text-decoration:none; display:inline-block; margin-top:8px }
    .back{ display:inline-block; margin-top:12px; text-decoration:none; color:#034a86; font-weight:700; }

    /* Table docentes */
    .docentes-table{ width:100%; border-collapse:collapse; margin-top:12px; font-size:13px }
    .docentes-table th, .docentes-table td{ border:1px solid rgba(35,65,90,0.08); padding:8px; text-align:left }
    .docentes-table th{ background:linear-gradient(90deg, rgba(43,108,176,0.12), rgba(127,179,255,0.08)); color:var(--muted); font-weight:700 }

    /* small screens */
    @media(max-width:720px){
      .nav{ gap:8px }
      .hero h1{ font-size:18px }
      .hero h2{ font-size:16px }
    }
  </style>
</head>
<body>
  <div class="sheet">
    <div class="hero">
      <h1>UNIVERSIDAD NACIONAL DEL ALTIPLANO - PUNO</h1>
      <h2>INGENIER√çA ESTAD√çSTICA E INFORM√ÅTICA</h2>
      <h3>Programaci√≥n Num√©rica ‚Äî FINESI</h3>
      <p><strong>Estudiante:</strong> Sadith Lina Apaza &nbsp; | &nbsp; <strong>Docente:</strong> Ing. Fred Torres Cruz</p>
    </div>

    <div class="nav">
      <button onclick="show('home')">Inicio</button>
      <button onclick="show('mod1')">M√≥dulo 1</button>
      <button onclick="show('mod2')">M√≥dulo 2</button>
      <button onclick="show('mod3')">M√≥dulo 3</button>
      <button onclick="show('mod4')">M√≥dulo 4</button>
      <button onclick="show('mod5')">M√≥dulo 5</button>
      <button onclick="show('mod6')">M√≥dulo 6</button>
      <button onclick="show('mod7')">M√≥dulo 7</button>
      <button onclick="show('mod8')">M√≥dulo 8</button>
      <button onclick="show('docentes')">Docentes</button>
      <button onclick="show('indiceh')">√çndice H</button>
      <button onclick="show('gradiente')">Gradiente</button>
      <button onclick="show('OLSyGD')">Metodo OLS y GD</button>
      <button onclick="show('comparacion')">comparacion</button>
      <button onclick="show('Supervivencia')">Supervivencia</button>
    </div>

    <!-- HOME / INSTRUCCIONES -->
    <section id="home" class="section active">
      <h2>Bienvenido/a</h2>
      <p class="theory">Este repositorio tiene como prop√≥sito recopilar, organizar y compartir implementaciones, ejercicios y proyectos desarrollados 
        en el curso de Programaci√≥n Num√©rica. Aqu√≠ encontrar√°s soluciones a problemas matem√°ticos mediante m√©todos computacionales, aplicando principios de an√°lisis num√©rico y buenas pr√°cticas de programaci√≥n..</p>
      <p>Usa los botones de arriba para navegar. Cada m√≥dulo tiene un bot√≥n para volver aqu√≠.</p>
    </section>

    <!-- M√≥dulo 1 -->
    <section id="mod1" class="section">
      <h2>M√≥dulo 1 ‚Äî Analizador de funciones</h2>
      <p class="theory">El analizador identifica variables y operaciones en una expresi√≥n matem√°tica. Esto ayuda a preprocesar la funci√≥n antes de evaluarla o graficarla, detectar s√≠mbolos no v√°lidos y preparar la expresi√≥n para m√©todos num√©ricos.</p>

      <h3>C√≥digo </h3>
      <pre><code class="language-python">
            class Analizador:
    def __init__(self, funcion):
        self.funcion = funcion

    def obtener_variables(self):
        variables = []
        for caracter in self.funcion:
            if caracter.isalpha() and caracter not in variables:
                variables.append(caracter)
        return variables

    def obtener_operaciones(self):
        operaciones = []
        for caracter in self.funcion:
            if caracter in "+-*/":
                operaciones.append(caracter)
        return operaciones

funcion = input("Escribe una funci√≥n matem√°tica: ")

analizador = Analizador(funcion)

print("
 RESULTADO ")
print("Variables encontradas:", analizador.obtener_variables())
print("Operaciones encontradas:", analizador.obtener_operaciones())
              </code></pre>
      
        <p><a class="download" href="analizador.py" download>Descargar analizador.py</a></p>
        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>

      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>

    <!-- M√≥dulo 2 -->
    <section id="mod2" class="section">
      <h2>M√≥dulo 2 ‚Äî Graficadora</h2>
      <p class="theory">La graficadora transforma expresiones en representaciones visuales (en este caso ASCII) para funciones lineales. Para $y = mx + b$, la pendiente $m$ y la ordenada al origen $b$ determinan la inclinaci√≥n y la posici√≥n de la recta.</p>
      <p><strong>F√≥rmula</strong>: \( y = m x + b \)</p>

      <h3>C√≥digo </h3>
      <pre><code class="language-python">class GraficadoraLineal:
    def __init__(self, expresion1, expresion2):
        self.expresion1 = expresion1
        self.expresion2 = expresion2
        self.x = []
        self.y1 = []
        self.y2 = []

    def generar_valores(self):
        x = -10
        while x <= 10:
            self.x.append(x)
            self.y1.append(eval(self.expresion1))
            self.y2.append(eval(self.expresion2))
            x = x + 1

    def graficar_consola(self):
        for i in range(len(self.x)):
            espacios1 = " " * (self.y1[i] + 20)
            linea = f"x={self.x[i]:>3} | {espacios1}*"

            espacios2 = " " * (self.y2[i] + 20)
            linea2 = f"{espacios2}#"

            print(linea + linea2)

f1 = input("Ingresa la primera funcion lineal: ")
f2 = input("Ingresa la segunda funcion lineal: ")

mi_grafica = GraficadoraLineal(f1, f2)
mi_grafica.generar_valores()
mi_grafica.graficar_consola()</code></pre>
      
<p><a class="download" href="graficadora.py" download>Descargar graficadora.py</a></p>
        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>
      
      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>

    <!-- M√≥dulo 3 -->
    <section id="mod3" class="section">
      <h2>M√≥dulo 3 ‚Äî Restricciones</h2>
      <p class="theory">Las restricciones delimitan regiones del dominio donde la funci√≥n es v√°lida. √ötiles en optimizaci√≥n para definir regiones factibles. En tu c√≥digo, las restricciones se eval√∫an punto por punto y se muestra una cuadr√≠cula ASCII con los puntos factibles marcados.</p>

      <h3>C√≥digo </h3>
      <pre><code class="language-python">
          class Restriccion:
    def __init__(self, expresion):
        self.expresion = expresion.replace(" ", "")

    def cumple(self, x, y):
        expr = self.expresion.replace("x", str(x)).replace("y", str(y))
        try:
            return eval(expr)
        except Exception as e:
            print("Error evaluando la restricci√≥n:", self.expresion, "->", e)
            return False

class ProblemaASCII:
    def __init__(self):
        self.restricciones = []

    def ingresar_datos(self):
        n = int(input("¬øCu√°ntas restricciones?: ").strip())
        for i in range(n):
            r = input(f"Restricci√≥n #{i+1}: ")
            self.restricciones.append(Restriccion(r))

        print("\n--- RANGOS ---")
        self.x_min = int(input("x m√≠nimo : ").strip())
        self.x_max = int(input("x m√°ximo : ").strip())
        self.y_min = int(input("y m√≠nimo : ").strip())
        self.y_max = int(input("y m√°ximo : ").strip())

        paso = input("Paso de la cuadr√≠cula (enteros, por defecto 1): ").strip()
        self.step = int(paso) if paso != "" else 1

    def punto_factible(self, x, y):
        for r in self.restricciones:
            if not r.cumple(x, y):
                return False
        return True

    def listar_puntos_factibles(self):
        factibles = []
        for y in range(self.y_min, self.y_max + 1, self.step):
            for x in range(self.x_min, self.x_max + 1, self.step):
                if self.punto_factible(x, y):
                    factibles.append((x, y))
        return factibles

    def imprimir_ascii(self):
        xs = list(range(self.x_min, self.x_max + 1, self.step))
        ys = list(range(self.y_min, self.y_max + 1, self.step))

        print("\n=== GR√ÅFICA  ===")
        header = "    " 
        for x in xs:
            if (x - self.x_min) % (max(1, (len(xs)//10))) == 0:
                header += f"{str(x).rjust(2)}"
            else:
                header += "  "
        print(header)

        for y in reversed(ys): 
            line = f"{str(y).rjust(3)} "  
            for x in xs:
                if self.punto_factible(x, y):
                    line += " #"
                else:
                    line += " ."
            print(line)

        footer = "    "
        for x in xs:
            if (x - self.x_min) % (max(1, (len(xs)//10))) == 0:
                footer += f"{str(x).rjust(2)}"
            else:
                footer += "  "
        print(footer)
        print("\nLeyenda: '#' punto factible, '.' no factible.")

    def ejecutar(self):
        self.ingresar_datos()
        factibles = self.listar_puntos_factibles()
        if not factibles:
            print("\nNo se encontraron puntos factibles en el rango dado.")
        else:
            print(f"\nSe encontraron {len(factibles)} puntos factibles:")
            for p in factibles[:20]:
                print(" ", p)
        self.imprimir_ascii()

def main():
    prog = ProblemaASCII()
    prog.ejecutar()

if __name__ == "__main__":
    main()

        </code></pre>
      
      <p><a class="download" href="Restricciones.py" download>Descargar Restricciones.py</a></p>
       <p><a class="download" href="Restricciones.pdf" download>Descargar Restricciones.pdf</a></p>
        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>
      
      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>

    <!-- M√≥dulo 4 -->
    <section id="mod4" class="section">
      <h2>M√≥dulo 4 ‚Äî M√©todo Newton Raphson</h2>
      <p class="theory">Newton-Raphson es un m√©todo iterativo para encontrar ra√≠ces mediante la f√≥rmula $x_{n+1}=x_n - f(x_n)/f'(x_n)$. Converge r√°pidamente si la aproximaci√≥n inicial es buena y la derivada no se anula.</p>

      <h3>C√≥digo </h3>
      <pre><code class="language-python">import math

import math

class NewtonRaphson:
    def __init__(self):
        pass

    def f(self, x, expr):
        return eval(expr, {"__builtins__":None}, {"x":x, **math.__dict__})

    def ejecutar(self):
        expr = input("Ingrese f(x): ").strip()
        dexpr = input("Ingrese f'(x): ").strip()
        x0 = float(input("x0: "))
        tol = float(input("Tolerancia (ej: 1e-6): "))
        maxit = int(input("Iteraciones maximas: "))
        x = x0
        for i in range(1, maxit+1):
            fx = self.f(x, expr)
            dfx = self.f(x, dexpr)
            if dfx == 0:
                print("Derivada cero. Deteniendo.")
                return
            x_new = x - fx/dfx
            if abs(x_new - x) < tol:
                print(f"Ra√≠z: {x_new}")
                print(f"f(ra√≠z): {self.f(x_new, expr)}")
                print(f"Iteraciones: {i}")
                return
            x = x_new
        print(f"Resultado tras {maxit} iter: {x}")
        print(f"f(aprox): {self.f(x, expr)}")

if __name__ == "__main__":
    NewtonRaphson().ejecutar()
      </code></pre>

      <p><a class="download" href="Newton Raphson.py" download>Descargar Newton Raphson.py</a></p>
        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>
      
      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>

    <!-- M√≥dulo 5 -->
    <section id="mod5" class="section">
      <h2>M√≥dulo 5 ‚Äî M√©todo Punto Fijo</h2>
      <p class="theory">El m√©todo de punto fijo reescribe $f(x)=0$ como $x=g(x)$ y aplica iteraciones $x_{n+1}=g(x_n)$. Convergencia si $|g'(x)|<1$ en el intervalo.</p>

      <h3>C√≥digo </h3>
      <pre><code class="language-python">
          import math

class PuntoFijo:
    def __init__(self):
        pass

    def g(self, x, expr):
        safe_locals = {
            "x": x,
            "ln": math.log,        
            "log": math.log,       
            "log10": math.log10,   
            "exp": math.exp,
            "sqrt": math.sqrt,
            "e": math.e,
            "pi": math.pi,
            **{k: getattr(math, k) for k in dir(math) if not k.startswith("__")}
        }
        return eval(expr, {"__builtins__": None}, safe_locals)

    def ejecutar(self):
        expr = input("Ingrese g(x) para x = g(x): ").strip()
        x0 = float(input("x0: "))
        tol = float(input("Tolerancia (ej: 1e-6): "))
        maxit = int(input("Iteraciones m√°ximas: "))

        x = x0
        for i in range(1, maxit + 1):
            x_new = self.g(x, expr)
            error = abs((x_new - x) / x_new) * 100 if x_new != 0 else float('inf')

            print(f"Iteraci√≥n {i}: x = {x_new:.10f}, Error = {error:.6f}%")

            if error < tol * 100:  
                print(f"\nPunto fijo: {x_new}")
                print(f"Iteraciones: {i}")
                print(f"Error porcentual final: {error:.6f}%")
                return

            x = x_new

        print(f"\nResultado tras {maxit} iteraciones: {x}")
        print(f"Error porcentual final: {error:.6f}%")

if __name__ == "__main__":
    PuntoFijo().ejecutar()
    </code></pre>

      <p><a class="download" href="punto fijo.py" download>Descargar punto fijo.py</a></p>
        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>
        
      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>

    <!-- M√≥dulo 6 -->
    <section id="mod6" class="section">
      <h2>M√≥dulo 6 ‚Äî M√©todo de Bisecci√≥n</h2>
      <p class="theory">Bisecci√≥n localiza una ra√≠z en un intervalo con cambio de signo: divide repetidamente y mantiene el subintervalo que contiene la ra√≠z. Garant√≠a de convergencia aunque lenta (lineal).</p>

      <h3>C√≥digo </h3>
      <pre><code class="language-python">
        import math

class Biseccion:
    def __init__(self):
        pass

    def f(self, x, expr):
        return eval(expr, {"__builtins__":None}, {"x":x, **math.__dict__})

    def ejecutar(self):
        expr = input("Ingrese f(x) : ").strip()
        a = float(input("a: "))
        b = float(input("b: "))
        tol = float(input("Tolerancia (ej: 1e-6): "))
        maxit = int(input("Iteraciones maximas: "))
        fa = self.f(a, expr)
        fb = self.f(b, expr)
        if fa * fb > 0:
            print("No hay cambio de signo en el intervalo.")
            return
        for i in range(1, maxit+1):
            c = (a + b) / 2.0
            fc = self.f(c, expr)
            if abs(fc) == 0 or (b - a) / 2.0 < tol:
                print(f"Ra√≠z: {c}")
                print(f"f(ra√≠z): {fc}")
                print(f"Iteraciones: {i}")
                return
            if fa * fc < 0:
                b = c
                fb = fc
            else:
                a = c
                fa = fc
        print(f"Ra√≠z aproximada tras {maxit} iter: {c}")
        print(f"f(ra√≠z): {fc}")

if __name__ == "__main__":
    Biseccion().ejecutar()
    </code></pre>

       <p><a class="download" href="M√©todo de Bisecci√≥n.py" download>Descargar M√©todo de Bisecci√≥n.py</a></p>
        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>
      
      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>

    <!-- M√≥dulo 7 -->
    <section id="mod7" class="section">
      <h2>M√≥dulo 7 ‚Äî M√©todo de Regula Falsi (Falsa Posici√≥n)</h2>
      <p class="theory">Regula Falsi usa la secante entre los extremos del intervalo para aproximar la ra√≠z: puede converger m√°s r√°pido que bisecci√≥n pero en algunos casos se estanca.</p>

      <h3>C√≥digo </h3>
      <pre><code class="language-python">
        import math

class RegulaFalsi:
    def __init__(self):
        pass

    def f(self, x, expr):
        return eval(expr, {"__builtins__":None}, {"x":x, **math.__dict__})

    def ejecutar(self):
        expr = input("Ingrese f(x) : ").strip()
        a = float(input("a: "))
        b = float(input("b: "))
        tol = float(input("Tolerancia (ej: 1e-6): "))
        maxit = int(input("Iteraciones maximas: "))
        fa = self.f(a, expr)
        fb = self.f(b, expr)
        if fa * fb > 0:
            print("No hay cambio de signo en el intervalo.")
            return
        c = a
        for i in range(1, maxit+1):
            c = (a * fb - b * fa) / (fb - fa)
            fc = self.f(c, expr)
            if abs(fc) < tol:
                print(f"Ra√≠z: {c}")
                print(f"f(ra√≠z): {fc}")
                print(f"Iteraciones: {i}")
                return
            if fa * fc < 0:
                b = c
                fb = fc
            else:
                a = c
                fa = fc
        print(f"Ra√≠z aproximada tras {maxit} iter: {c}")
        print(f"f(ra√≠z): {self.f(c, expr)}")

if __name__ == "__main__":
    RegulaFalsi().ejecutar()

    </code></pre>

       <p><a class="download" href="M√©todo de Regula Falsi (Falsa Posici√≥n).py" download>Descargar M√©todo de Regula Falsi (Falsa Posici√≥n).py</a></p>
        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>
      
      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>

    <!-- M√≥dulo 8 -->
    <section id="mod8" class="section">
      <h2>M√≥dulo 8 ‚Äî M√©todo de la Secante</h2>
      <p class="theory">La secante aproxima la derivada con una diferencia finita entre dos puntos; no requiere la derivada expl√≠cita y suele converger m√°s r√°pido que bisecci√≥n en muchos casos.</p>

      <h3>C√≥digo </h3>
      <pre><code class="language-python">
        import math

class Secante:
    def __init__(self):
        pass

    def f(self, x, expr):
        return eval(expr, {"__builtins__":None}, {"x":x, **math.__dict__})

    def ejecutar(self):
        expr = input("Ingrese f(x) : ").strip()
        x0 = float(input("x0: "))
        x1 = float(input("x1: "))
        tol = float(input("Tolerancia (ej: 1e-6): "))
        maxit = int(input("Iteraciones maximas: "))
        f0 = self.f(x0, expr)
        f1 = self.f(x1, expr)
        for i in range(1, maxit+1):
            denom = (f1 - f0)
            if denom == 0:
                print("Denominador cero. Deteniendo.")
                return
            x2 = x1 - f1 * (x1 - x0) / denom
            if abs(x2 - x1) < tol:
                print(f"Ra√≠z: {x2}")
                print(f"f(ra√≠z): {self.f(x2, expr)}")
                print(f"Iteraciones: {i}")
                return
            x0, f0 = x1, f1
            x1, f1 = x2, self.f(x2, expr)
        print(f"Resultado tras {maxit} iter: {x1}")
        print(f"f(aprox): {self.f(x1, expr)}")

if __name__ == "__main__":
    Secante().ejecutar()


    </code></pre>
      
      <p><a class="download" href="secante.py" download>Descargar secante.py</a></p>
        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>
      
      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>

    <!-- Secci√≥n FINAL: √çndice H de los docentes  -->
    <section id="docentes" class="section">
      <h2>√çNDICE H DE LOS DOCENTES DE FINESI</h2>
      <p>La siguiente tabla muestra la verificaci√≥n en Scopus (si se encontr√≥ cuenta), n√∫mero de documentos, citas e √≠ndice h.</p>

      <table class="docentes-table" id="tabla-docentes">
        <thead>
          <tr>
            <th>Docente </th>
            <th>Cuenta Scopus</th>
            <th>Publicaciones</th>
            <th>Citas</th>
            <th>√çndice H</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>ALVAREZ ROZAS, Teresa paola</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>APAZA CUTIPA, Renzo</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>APAZA TARQUI, Alejandro</td><td>S√≠</td><td>5</td><td>6</td><td>1</td></tr>
          <tr><td>CANQUI FLORES, Bernab√©</td><td>S√≠</td><td>8</td><td>20</td><td>3</td></tr>
          <tr><td>CARPIO VARGAS, Edgar eloy</td><td>S√≠</td><td>9</td><td>26</td><td>3</td></tr>
          <tr><td>COYLA DME, Leonel</td><td>S√≠</td><td>5</td><td>1</td><td>1</td></tr>
          <tr><td>GONZALES ACHATA, Alfredo ernesto</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>JUAREZ VARGAS, Juan carlos</td><td>S√≠</td><td>3</td><td>2</td><td>1</td></tr>
          <tr><td>LLUEN VALLEJOS, Cesar augusto</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>LOPEZ CUEVA, Milton antonio</td><td>S√≠</td><td>6</td><td>2</td><td>1</td></tr>
          <tr><td>MENDOZA MOLLOCONDO, Charles ignacio</td><td>S√≠</td><td>8</td><td>17</td><td>3</td></tr>
          <tr><td>MORILLOS VALDERRAMA, Santos octavio</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>PEREZ QUISPE, Samuel donato</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>PUMA HUAMAN, Beto</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>QUISPE CARITA, Angel javier</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>SALAS PILCO, Maria maura</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>TITO LIPA, Jos√© p√°nfilo</td><td>S√≠</td><td>3</td><td>0</td><td>0</td></tr>
          <tr><td>TUMI FIGUEROA, Ernesto nayer</td><td>S√≠</td><td>6</td><td>23</td><td>3</td></tr>
          <tr><td>VILLASANTE SARAVIA, Fredy heric</td><td>S√≠</td><td>2</td><td>7</td><td>2</td></tr>
          <tr><td>ALEM√ÅN GONZALES, Leonid</td><td>S√≠</td><td>4</td><td>0</td><td>0</td></tr>
          <tr><td>AZA√ëERO DE A AGUIRRE, Emma orfelinda</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>CHOQUEJAHUA ACERO, Remo</td><td>S√≠</td><td>2</td><td>2</td><td>1</td></tr>
          <tr><td>HUATA PANCA, Percy</td><td>S√≠</td><td>3</td><td>14</td><td>2</td></tr>
          <tr><td>IB√Å√ëEZ QUISPE, Vladimiro</td><td>S√≠</td><td>21</td><td>52</td><td>5</td></tr>
          <tr><td>PAREDES QUISPE, Juan reynaldo</td><td>S√≠</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>PARI CONDORI, Elqui yeye</td><td>S√≠</td><td>3</td><td>1</td><td>1</td></tr>
          <tr><td>QUISPE MAMANI, Godofredo</td><td>S√≠</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>QUISPE YAPO, Edgardo</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>ROQUE CLAROS, Roberto elvis</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>VARGAS VALVERDE, Confesor milan</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
          <tr><td>TORRES CRUZ, Fred</td><td>S√≠</td><td>40</td><td>74</td><td>4</td></tr>
          <tr><td>ROSSEL BERNEDO, Luis Alberth</td><td>No se encontr√≥ autor</td><td>-</td><td>-</td><td>-</td></tr>
        </tbody>
      </table>

      <!-- Estad√≠stica  -->
      <h3 style="margin-top:14px">Resumen estad√≠stico</h3>
      <ul>
        <li><strong>Total docentes:</strong> 32</li>
        <li><strong>Docentes con cuenta Scopus (verificados como "S√≠"):</strong> 18</li>
        <li><strong>Docentes sin cuenta en Scopus o no se encontro autor:</strong> 14</li>
        <li><strong>√çndice H promedio (entre los que tienen valor num√©rico):</strong> aprox. 2.1</li>
        <li><strong>M√°ximo √≠ndice H:</strong> 5 (Vladimiro Ib√°√±ez Quispe)</li>
      </ul>

      <canvas id="scopusChart" width="700" height="200"></canvas>

      <p><strong>Observaci√≥n:</strong> varias filas aparecen con '-' cuando no se encontr√≥ autor en Scopus o no hay datos p√∫blicos.</p>
      <p class="back"><a href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a></p>
    </section>

  </div>

  <script>
    // Navegaci√≥n: mostrar secci√≥n
    function show(id){
      document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
      const el = document.getElementById(id);
      if(el) el.classList.add('active');
      window.scrollTo({top:0,behavior:'smooth'});
    }

    // Inicial: mostrar home
    show('home');

    // Crear gr√°fico Scopus S√≠/No y mostrar valores encima de barras
    (function(){
      const yes = 18;
      const no = 14;
      const ctx = document.getElementById('scopusChart').getContext('2d');
      const data = {
        labels: ['Cuenta Scopus: S√≠', 'Cuenta Scopus: No'],
        datasets: [{
          label: 'Docentes',
          data: [yes, no],
          backgroundColor: ['#4da6ff','#cfefff']
        }]
      };
      const config = {
        type: 'bar',
        data,
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: { enabled: true },
            title: { display: true, text: 'Distribuci√≥n de docentes seg√∫n Scopus' }
          },
          scales: {
            y: { beginAtZero: true, ticks: { stepSize: 1 } }
          }
        },
        plugins: [{
          id: 'showValues',
          afterDatasetsDraw(chart) {
            const ctx = chart.ctx;
            chart.data.datasets.forEach((dataset, i) => {
              const meta = chart.getDatasetMeta(i);
              meta.data.forEach((bar, index) => {
                const data = dataset.data[index];
                ctx.fillStyle = '#034a7a';
                ctx.font = '600 13px Inter, Arial';
                const x = bar.x;
                const y = bar.y - 8;
                ctx.textAlign = 'center';
                ctx.fillText(String(data), x, y);
              });
            });
          }
        }]
      };
      new Chart(ctx, config);
    })();
  </script>
  <section id="indiceh" class="section">
      <h2>Autores destacados ‚Äî √çndice H &gt; 10</h2>

      <p class="theory">
        <strong>Concepto:</strong> El <strong>√≠ndice H</strong> (h-index) mide simult√°neamente la productividad y el impacto de un autor: un investigador tiene √≠ndice H = <em>h</em> si dispone de <em>h</em> trabajos que han recibido, cada uno, al menos <em>h</em> citas. A continuaci√≥n se muestran autores seleccionados con √≠ndice H mayor a 10.
      </p>

      <!-- Autor: Hinton -->
      <div class="author-card" id="hinton">
  <div class="author-meta">
    <div class="title" style="font-weight:bold; text-align:center; font-size:1.2em;">
      Hinton, Geoffrey E.
    </div>
  </div>
</div>
          <div>Universidad de Toronto, Canad√°</div>
          <div style="margin-top:8px; font-size:13px; color:#385a78">Scopus ID: <strong>7006699573</strong></div>
        </div>

        <div style="flex:1">
          <div class="metrics" aria-hidden="true">
            <div>
              <div style="font-size:12px; color:#0b3d66">Citas totales</div>
              <div style="font-size:18px">424.830</div>
            </div>
            <div>
              <div style="font-size:12px; color:#0b3d66">Documentos</div>
              <div style="font-size:18px">271</div>
            </div>
            <div>
              <div style="font-size:12px; color:#0b3d66">√çndice H</div>
              <div style="font-size:18px">117</div>
            </div>
          </div>

          <div style="margin-top:12px" class="pubs">
            <strong>Publicaciones :</strong>
            <ul>
             <li>Nobel Lecture: Boltzmann Machines</li>
              <li>Managing extreme AI risks amid rapid progress: preparation requires technical research and development, as well as adaptive and proactive governance.</li>
              <li>Robust and efficient generalization in self-supervised machine learning for diagnostic imaging</li>
              <li>How to represent part-whole hierarchies in a neural network</li>
              <li>ANALOG BITS: Generating discrete data using diffusion models with self-conditioning</li>
              <li>A generalist framework for panoptic segmentation of images and videos</li>
              <li>Forward-scale gradient with local losses</li>
              <li>PIX2SEQ: A language modeling framework for object detection</li>
              <li>Fast-weight language models for meta-learning</li>
              <li>A unified sequence interface for vision tasks</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Autor: Bengio -->
    <div class="author-card" id="bengio">
  <div class="author-meta">
    <div class="title" style="font-weight:bold; text-align:center; font-size:1.2em;">
      Bengio, Yoshua
    </div>
  </div>
</div>
          <div>Montreal Institute for Learning Algorithms, Canad√°</div>
          <div style="margin-top:8px; font-size:13px; color:#385a78">Scopus ID: <strong>7003958245</strong></div>
        </div>

        <div style="flex:1">
          <div class="metrics" aria-hidden="true">
            <div>
              <div style="font-size:12px; color:#0b3d66">Citas totales</div>
              <div style="font-size:18px">400.851</div>
            </div>
            <div>
              <div style="font-size:12px; color:#0b3d66">Documentos</div>
              <div style="font-size:18px">641</div>
            </div>
            <div>
              <div style="font-size:12px; color:#0b3d66">√çndice H</div>
              <div style="font-size:18px">162</div>
            </div>
          </div>

          <div style="margin-top:12px" class="pubs">
            <strong>Publicaciones :</strong>
            <ul>
              <li>The illusions of AI consciousness: the belief that AI is conscious is not without risks</li>
              <li>What makes a theory of consciousness unscientific?</li>
              <li>Causal machine learning for single-cell genomics</li>
              <li>Causal discovery in astrophysics: unraveling the coevolution between supermassive black holes and galaxies</li>
              <li>Low-computational-cost unlearning through sparse representations</li>
            </ul>
          </div>
        </div>
      </div>

      <p style="margin-top:10px; font-size:13px; color:#0b3d66">
      </p>

      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>
  
  <!--Gradiente-->
    <section id="gradiente" class="section">
      <h2>Metodo de Gradiente</h2>
      <p class="theory">El m√©todo del gradiente es una t√©cnica matem√°tica usada para encontrar los m√≠nimos o m√°ximos de una funci√≥n.
        Se basa en el gradiente, que es un vector formado por las derivadas parciales de la funci√≥n y que indica la direcci√≥n y rapidez del cambio m√°s grande de dicha funci√≥n en un punto dado.
        En el caso de una funci√≥n ùëì(ùë•), el m√©todo del descenso del gradiente busca el punto donde la funci√≥n alcanza su valor
        m√≠nimo actualizando los valores de ùë• en la direcci√≥n opuesta al gradiente, mediante la ecuaci√≥n:</p>
       <p><strong>F√≥rmula</strong>: \( xk + 1 ‚Äã= xk ‚Äã‚àí Œ±‚àá f(xk‚Äã) \)</p>

      <h3>Ejemplo en R </h3>
      <pre><code class="language-R">
        import math

# M√âTODO DEL GRADIENTE 
f <- function(x){ x^2 } 
f_deriv <- function(x){ 2*x } 
# Par√°metros 
x0 <- 3 
n <- 0.01        # tasa de aprendizaje 
max_iter <- 100 
# Guardar el recorrido 
x_valores <- numeric(max_iter) 
f_valores <- numeric(max_iter) 
# Iteraciones 
for (i in 1:max_iter) { 
x_nuevo <- x0 - (n * f_deriv(x0))  
x0 <- x_nuevo 
x_valores[i] <- x0 
f_valores[i] <- f(x0) 
} 
cat("El m√≠nimo est√° en x =", x0, "con f(x) =", f(x0), "\n") 
# Dibuja la funci√≥n 
x_seq <- seq(-3, 3, 0.1) 
plot(x_seq, f(x_seq), type = "l", col = "blue", lwd = 2, 
main = "M√©todo del Gradiente para f(x) = x^2", 
xlab = "x", ylab = "f(x)") 
# Puntos del recorrido 
points(x_valores, f_valores, col = "red", pch = 19) 
lines(x_valores, f_valores, col = "red", lwd = 2) 
# Punto final (m√≠nimo) 
points(x0, f(x0), col = "green", pch = 19, cex = 1.5) 

    </code></pre>
      
      <p><a class="download" href="gradiente.R" download>Descargar gradiente.R</a></p>
        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>
      
      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>

  <!--comparacion de metodos-->
    <section id="OLSyGD" class="section">
      <h2>Comparacion de los Metodos OLS y GD</h2>
      <p class="theory">El m√©todo de M√≠nimos Cuadrados Ordinarios (OLS) y el m√©todo del Gradiente Descendente (GD) son t√©cnicas utilizadas para ajustar modelos y estimar par√°metros, especialmente en regresi√≥n.</p>

<p class="theory">* OLS encuentra la soluci√≥n de forma anal√≠tica, resolviendo directamente un sistema de ecuaciones para obtener los coeficientes que minimizan el error cuadr√°tico. Es r√°pido y exacto cuando los datos son pocos o el sistema no es muy grande.</p>

<p class="theory">* GD, en cambio, es un m√©todo iterativo que ajusta los par√°metros paso a paso siguiendo la direcci√≥n del gradiente hasta llegar al m√≠nimo. Es m√°s lento, pero resulta √∫til cuando hay grandes vol√∫menes de datos o muchas variables, donde OLS ser√≠a costoso o imposible de calcular directamente.:</p>

      <h3>Ejemplo en R </h3>
      <pre><code class="language-R">

# REGRESI√ìN LINEAL: 

set.seed(123)  # Para reproducibilidad

n <- 1e6
x <- runif(n, 0, 10)
beta_0 <- 5
beta_1 <- 3
epsilon <- rnorm(n, mean = 0, sd = 2)
y <- beta_0 + beta_1 * x + epsilon

# ------------------------------------------------------
# M√âTODO 1: OLS (M√çNIMOS CUADRADOS ORDINARIOS)
# ------------------------------------------------------
cat("\n=== M√âTODO OLS ===\n")
tiempo_ols <- system.time({
  modelo_ols <- lm(y ~ x)
})
summary(modelo_ols)

cat("\n--- Resultados OLS ---\n")
cat("Beta_0 estimado:", coef(modelo_ols)[1], "\n")
cat("Beta_1 estimado:", coef(modelo_ols)[2], "\n")
cat("Tiempo de ejecuci√≥n OLS (segundos):\n")
print(tiempo_ols)

# ------------------------------------------------------
# M√âTODO 2: DESCENSO DEL GRADIENTE
# ------------------------------------------------------
cat("\n=== M√âTODO GD ===\n")

# Hiperpar√°metros
alpha <- 0.000001     # tasa de aprendizaje
iteraciones <- 1000   # n√∫mero de iteraciones

# Inicializaci√≥n
b0 <- 0
b1 <- 0

tiempo_gd <- system.time({
  for (i in 1:iteraciones) {
    y_pred <- b0 + b1 * x
    grad_b0 <- (-2/n) * sum(y - y_pred)
    grad_b1 <- (-2/n) * sum(x * (y - y_pred))
    b0 <- b0 - alpha * grad_b0
    b1 <- b1 - alpha * grad_b1
  }
})

cat("\n--- Resultados GD ---\n")
cat("Beta_0 estimado:", b0, "\n")
cat("Beta_1 estimado:", b1, "\n")
cat("Tiempo de ejecuci√≥n GD (segundos):\n")
print(tiempo_gd)

    </code></pre>
      
      <p><a class="download" href="OLS,.R" download>Descargar OLS,.R</a></p>
      <p><a class="download" href="M√©todo OLS y GD.pdf" download>Descargar M√©todo OLS y GD.pdf</a></p>
        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>
      
      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>
      
       <!--Supervivencia-->
    <section id="Supervivencia" class="section"> 
      <h2>Juego de Supervivencia</h2>
       <p class="theory">
    Durante una actividad grupal dirigida por el ingeniero, se realiz√≥ un juego con el objetivo de aplicar el razonamiento l√≥gico 
    y la simulaci√≥n en programaci√≥n, utilizando posteriormente el lenguaje R para modelar la situaci√≥n.</p>

  <h3> Objetivo del juego</h3>
  <p>
    El prop√≥sito del juego era que todos los integrantes del grupo (9 en total) lograran obtener al menos un chupet√≠n cada uno.
    Para ello, se deb√≠an realizar una serie de intercambios estrat√©gicos de caramelos, siguiendo ciertas reglas previamente establecidas.
  </p>

  <h3>Desarrollo de la actividad</h3>
  <p>
    Al inicio, el ingeniero entreg√≥ dos caramelos aleatorios a cada participante, sumando 18 caramelos en total para el grupo.
    Hab√≠a tres tipos de caramelos, representados por las letras A, B y C (A = caramelo amarillo, B = caramelo blanco, C = caramelo redondo).
  </p>
  <p>
    Los integrantes debian juntar sus caramelos entre s√≠ y realizar intercambios con el ‚ÄúIngeniero‚Äù para llegar a la meta, 
    siguiendo las reglas oficiales del juego.
  </p>

  <h3>Reglas del juego</h3>

  <h4>üîπ Regla 1:</h4>
  <p>
    Por cada combinaci√≥n de <strong>A + B + C</strong>, el grupo pod√≠a canjear <strong>1 chupet√≠n</strong>.
  </p>

  <h4>üîπ Regla 2:</h4>
  <p>
    Si el grupo reun√≠a 6 caramelos compuestos por <strong>2A + 2B + 2C</strong>, pod√≠an canjearlos por:
    <br>‚Üí <strong>2 chupetines + 1 caramelo aleatorio </strong>.
  </p>

  <h4>üîπ Regla 3:</h4>
  <p> Se pod√≠a intercambiar <strong>1 chupet√≠n</strong> por <strong>3 caramelos aleatorios</strong>.
  </p>

  <h3>Estrategia del grupo</h3>
  <p>
    El grupo trabaj√≥ en conjunto, combinando sus caramelos y aplicando las reglas de forma estrat√©gica.
    Primero, se concentraron en aplicar la Regla 2 para conseguir varios chupetines de forma r√°pida.
  </p>
  <p>
    Cuando lograron 4 chupetines, decidieron arriesgarse aplicando la Regla 3, devolviendo algunos chupetines 
    para obtener m√°s caramelos y continuar los intercambios.
  </p>
  <p>
    Finalmente, al tener 8 chupetines y 3 caramelos diferentes, aplicaron la Regla 1 para completar la meta, consiguiendo los 9 chupetines necesarios 
    para que cada integrante obtuviera uno.
  </p>

  <h3>Aplicaci√≥n en R</h3>
  <p>
    Con base en esta din√°mica, se desarroll√≥ un c√≥digo en R que simula todo el proceso de intercambio, siguiendo las reglas descritas.
    El programa comienza con 18 caramelos aleatorios y ejecuta iteraciones hasta que el grupo alcanza los 9 chupetines, 
    aplicando las reglas en el orden l√≥gico:
  </p>

  <ol>
    <li>Regla 2 (intercambio principal)</li>
    <li>Regla 3 (intercambio estrat√©gico)</li>
    <li>Regla 1 (final de ajuste)</li>
  </ol>

  <p>El objetivo del c√≥digo es encontrar la soluci√≥n en el menor n√∫mero de iteraciones posibles, 
    reflejando el mismo razonamiento colectivo que se utiliz√≥ en la din√°mica real. </p>

      <h3>Codigo en R </h3>
      <pre><code class="language-R">
        tipos <- c("A", "B", "C") 
caramelos_aleatorios <- function(n) sample(tipos, n, replace = TRUE) 
set.seed(123)   
caramelos_grupo <- caramelos_aleatorios(9 * 2)   
chupetines <- 0 
objetivo <- 9   
cat(" Caramelos iniciales:", paste(caramelos_grupo, collapse = " "), "\n") 
# Regla 2: 2A + 2B + 2C ‚Üí 2 chupetines + 1 caramelo aleatorio 
regla2 <- function(caramelos, chupetines) { 
aplicado <- FALSE 
while (sum(caramelos == "A") >= 2 && 
sum(caramelos == "B") >= 2 && 
sum(caramelos == "C") >= 2) { 
for (x in c("A", "B", "C")) { 
caramelos <- caramelos[-which(caramelos == x)[1:2]] 
} 
chupetines <- chupetines + 2 
caramelos <- c(caramelos, sample(tipos, 1)) 
aplicado <- TRUE 
cat("Regla 2 aplicada ‚Üí +2 chupetines, +1 caramelo aleatorio\n") 
} 
return(list(caramelos, chupetines, aplicado)) 
} 
# Regla 3: 1 chupet√≠n ‚Üí 3 caramelos aleatorios 
regla3 <- function(caramelos, chupetines) { 
if (chupetines >= 2) {  # solo si tienen al menos 2 chupetines 
chupetines <- chupetines - 1 
nuevos <- sample(tipos, 3, replace = TRUE) 
caramelos <- c(caramelos, nuevos) 
cat("Regla 3 aplicada ‚Üí 1 chupet√≠n cambiado por:", paste(nuevos, collapse = " "), 
"\n") 
} 
return(list(caramelos, chupetines)) 
} 
# Regla 1: A + B + C ‚Üí 1 chupet√≠n 
regla1 <- function(caramelos, chupetines) { 
aplicado <- FALSE 
while (all(c("A", "B", "C") %in% caramelos)) { 
caramelos <- caramelos[-match(c("A", "B", "C"), caramelos)] 
chupetines <- chupetines + 1 
aplicado <- TRUE 
cat("Regla 1 aplicada ‚Üí +1 chupet√≠n (combinaci√≥n A+B+C)\n") 
} 
return(list(caramelos, chupetines, aplicado)) 
} 
iter <- 0 
repeat { 
iter <- iter + 1 
cat("\nIteraci√≥n", iter, "\n") 
cat("Caramelos:", paste(caramelos_grupo, collapse = " "),  
"- Chupetines:", chupetines, "\n") 
res2 <- regla2(caramelos_grupo, chupetines) 
caramelos_grupo <- res2[[1]] 
chupetines <- res2[[2]] 
if (chupetines >= 2 && chupetines < objetivo) { 
res3 <- regla3(caramelos_grupo, chupetines) 
caramelos_grupo <- res3[[1]] 
chupetines <- res3[[2]] 
} 
if (chupetines >= 8 && chupetines < objetivo) { 
res1 <- regla1(caramelos_grupo, chupetines) 
caramelos_grupo <- res1[[1]] 
chupetines <- res1[[2]] 
} 
# Mostrar progreso 
cat("Estado tras la iteraci√≥n:", chupetines, "chupetines,", 
length(caramelos_grupo), "caramelos.\n") 
if (chupetines >= objetivo) { 
cat("\nEl grupo logr√≥ obtener los 9 chupetines en", iter, "iteraciones\n") 
break 
} 
if (iter > 200) { 
cat("\nNo se logr√≥ el objetivo despu√©s de 200 iteraciones.\n") 
break 
} 
}
  </code></pre>
      
      <p><a class="download" href="Supervivencia.R" download>Descargar Supervivencia.R</a></p>
      <p><a class="download" href="SUPERVIVENCIA.pdf" download>Descargar SUPERVIVENCIA.pdf</a></p>

        <p class="reflection"><strong>Reflexi√≥n:</strong> ‚Äî</p>
      
      <a class="back" href="#" onclick="show('home');return false;">‚¨Ö Volver al inicio</a>
    </section>

  
  <section id="comparacion" class="section">
    <h2>Comparing the Moore‚ÄìPenrose Pseudoinverse and Gradient Descent for Solving Linear Regression Problems</h2>

    <p>
        El art√≠culo presenta un an√°lisis exhaustivo de dos m√©todos fundamentales para resolver problemas de regresi√≥n lineal:
        la pseudoinversa de Moore‚ÄìPenrose y el descenso por gradiente. Ambos enfoques permiten estimar los par√°metros del
        modelo lineal, pero lo hacen desde perspectivas muy diferentes: uno mediante una soluci√≥n directa y exacta, y el otro
        mediante un proceso iterativo.
    </p>

    <h3>1. Introducci√≥n</h3>

    <p>El modelo lineal se expresa como:</p>

    <div class="equation">
        <span class="math">y = XŒ≤ + Œµ</span>
    </div>

    <p>El objetivo es minimizar la funci√≥n de error:</p>

    <div class="equation">
        <span class="math">S(Œ≤) = ||XŒ≤ - y||^2</span>
    </div>

    <h3>2. Soluci√≥n mediante la Pseudoinversa de Moore‚ÄìPenrose</h3>

    <p>Las ecuaciones normales son:</p>

    <div class="equation">
        <span class="math">X·µÄXŒ≤ÃÇ = X·µÄy</span>
    </div>

    <p>Que llevan a la soluci√≥n:</p>

    <div class="equation">
        <span class="math">Œ≤ÃÇ‚Çö·µ¢‚Çô·µ• = (X·µÄX)‚Åª¬πX·µÄy</span>
    </div>

    <p>El costo computacional t√≠pico es:</p>

    <div class="equation">
        <span class="math">O(nd¬≤ + d¬≥)</span>
    </div>

    <h3>3. Soluci√≥n mediante Descenso por Gradiente</h3>

    <p>La regla de actualizaci√≥n es:</p>

    <div class="equation">
        <span class="math">Œ≤‚Çú‚Çä‚ÇÅ = Œ≤‚Çú - Œ± ‚àáS(Œ≤‚Çú)</span>
    </div>

    <p>El gradiente:</p>

    <div class="equation">
        <span class="math">‚àáS(Œ≤) = 2X·µÄ(XŒ≤ - y)</span>
    </div>

    <p>Actualizaci√≥n final:</p>

    <div class="equation">
        <span class="math">Œ≤‚Çú‚Çä‚ÇÅ = Œ≤‚Çú - 2Œ±X·µÄ(XŒ≤‚Çú - y)</span>
    </div>

    <p>La complejidad por iteraci√≥n es:</p>

    <div class="equation">
        <span class="math">O(nd)</span>
    </div>

    <h3>4. Metodolog√≠a Experimental</h3>

    <p>
        Se usaron datos sint√©ticos con diferentes grados de condicionamiento, as√≠ como California Housing y UCI Diabetes.
        Las m√©tricas evaluadas fueron:
    </p>

    <ul>
        <li>Tiempo de ejecuci√≥n</li>
        <li>Error cuadr√°tico medio (MSE)</li>
        <li>N√∫mero de iteraciones (solo para GD)</li>
    </ul>

    <h3>5. Resultados Principales</h3>

    <p>
        La pseudoinversa super√≥ al descenso por gradiente en tiempo para tama√±os peque√±os y medianos. Ambos m√©todos fueron
        precisos con matrices bien condicionadas, pero el descenso por gradiente fall√≥ o se volvi√≥ muy lento en casos de alto
        mal condicionamiento.
    </p>

    <h3>6. Conclusiones</h3>

    <p>
        La pseudoinversa es ideal para tama√±os peque√±os o moderados, mientras que el descenso por gradiente escala mejor a
        grandes vol√∫menes de datos. El condicionamiento de la matriz y la tasa de aprendizaje determinan el rendimiento del
        descenso por gradiente.
    </p>
</section>

<!-- Estilos sugeridos para "Opci√≥n B" -->
<style>
    .equation {
        text-align: center;
        margin: 18px 0;
        font-size: 1.25rem;
        font-weight: 600;
    }
    .math {
        padding: 6px 12px;
        display: inline-block;
        border-radius: 6px;
        background: #f0f0f0;
        font-family: "Times New Roman", serif;
    }
</style>

</body>
</html>
